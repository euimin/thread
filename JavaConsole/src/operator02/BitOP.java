package operator02;

public class BitOP {

	public static void main(String[] args) {
		//비트 연산는 비트 단위로 계산
		/*
		[쉬프트 연산자]
		-두항이 반드시 정수여야한다
		 정수 <<  비트수: 왼쪽으로 비트수만큼 이동하고 
		                  오른쪽에
					     남은 비트는 0으로 채운다

		 정수 >> 비트수 : 오른쪽으로 비트수만큼 이동하고
		 	              왼쪽에 남은 비트는 부호비트로 
		 	              채운다(1:음수,0:양수)
		*/
		byte b1 =10 ,bit1=2;
		int result =b1 << bit1;
		/*
		 * b1 : 0000 1010
		 * <<
		 * 2
		 * -------------------
		 *     0000 0000 0000 0000 0000 0000 0010 1000   => 32+8
		 */
		System.out.println("result="+result);
		
		result = b1 >> bit1;
		/*
		 * b1 : 0000 1010
		 * >>
		 * 2
		 * -------------------
		 *     0000 0000 0000 0000 0000 0000 0000 0010 => 2
		 */
		System.out.println("result="+result);
		
		b1 = -9;
		/*
		 * -9 : 1111 0111
		 * <<
		 * 2
		 * ---------------
		 *      1101 1100  =>
		 * 
		 * 
		 */
		
		result = b1 << bit1;
		System.out.println("result="+result);
		
		result = b1 >> bit1;
		/*
		 * -9 : 1111 0111
		 * >>
		 * 2
		 * ---------------
		 *      1111 1101=>-3		
		 */
		System.out.println("result="+result);
		/*
		비트 연산자 : &(and)  ^(xor)  |(or)  ~(not)
		- 두항이 정수여야 한다.
		- 두 항이 정수값일때 비트 연산자로 사용됨
		  그렇지 않고 두항이 비교식일때는 논리연산자로 
		  사용됨
		예]   3> 4 & 5 < 4 : &는 논리연산자
		        4 & 5 : & 는 비트 연산자
		

		  - & : 비트 연산시 둘다 1일때만 1 아니면 0
		  - | : 둘중의 하나라도 1이면 1
		  - ^ : 서로 배타적일때 즉 서로 값이 다를때는 
		        1 같으면 0
		  - ~ : 1이면 0 ,0이면 1		
		 * 
		 */
		
		b1 = 3;
		byte b2 =-15;
		/*
		 * 3  : 0000 0011
		 * &
		 * -15: 1111 0001
		 * -------------------
		 *      0000 0001  => 1
		 */
		System.out.println(b1 & b2);
		
		
		/*
		 * 3  : 0000 0011
		 * |
		 * -15: 1111 0001
		 * -------------------
		 *      1111 0011  => -13
		 */
		System.out.println(b1 | b2);
		
		/*
		 * 3  : 0000 0011
		 * ^
		 * -15: 1111 0001
		 * -------------------
		 *      1111 0010  => -14
		 */
		System.out.println(b1 ^ b2);
		/*
		 * -15: 1111 0001
		 * ~
		 * ---------------
		 *      0000 1110 ==>14
		 */
		System.out.println(~b2);
	}////////main

}///////////class
